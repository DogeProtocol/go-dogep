// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.
/*
 * QC Read API
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * API version: v1
 */

package main

import (
	"bytes"
	"encoding/json"
	"fmt"
	"io/ioutil"
	"log"
	"net"
	"net/http"
	"os"
	qcreadapi "github.com/DogeProtocol/dp/relay/qcreadapi"
	qcwriteapi "github.com/DogeProtocol/dp/relay/qcwriteapi"
	"strconv"
)

type Config struct {
	Api		string `json:"api"`
	Ip		string `json:"ip"`
	Port	string `json:"port"`
}

type Configs struct {
	Configs []Config `json:"configs"`
}

func main() {
	if len(os.Args) < 2 {
		printHelp()
		return
	}

	if os.Args[1] == "qcreadapi" {

		configs := readConfigJsonDataFile("config.json")

		if len(configs) < 2{
			fmt.Println("Check config json file")
			return
		}

		qcApi := configs[0].Api
		ip := configs[0].Ip
		port := configs[0].Port

		if qcApi  != "qcreadapi" {
			fmt.Println("Check configuration qcApi value ", qcApi)
			return
		}

		if net.ParseIP(ip) == nil {
			fmt.Println("Check configuration ip value ", ip)
			return
		}

		if _, err := strconv.Atoi(port); err != nil {
			fmt.Println("Check configuration port value ", port)
			return
		}

		qcReadApi(ip, port)

	} else if os.Args[1] == "qcwriteapi" {

		configs := readConfigJsonDataFile("config.json")

		if len(configs) < 2{
			fmt.Println("Check config json file")
			return
		}

		qcApi := configs[1].Api
		ip := configs[1].Ip
		port := configs[1].Port

		if qcApi  != "qcwriteapi" {
			fmt.Println("Check configuration qcApi value ", qcApi)
			return
		}

		if net.ParseIP(ip) == nil {
			fmt.Println("Check configuration ip value ", ip)
			return
		}

		if _, err := strconv.Atoi(port); err != nil {
			fmt.Println("Check configuration port value ", port)
			return
		}

		qcWriteApi(ip, port)

	} else {
		printHelp()
	}
}

func qcReadApi(ip string, port string) {
	ReadApiAPIService := qcreadapi.NewReadApiAPIService()
	ReadApiAPIController := qcreadapi.NewReadApiAPIController(ReadApiAPIService)
	readRouter := qcreadapi.NewRouter(ReadApiAPIController)

	fmt.Println("Read api server is listening on : ", ip + ":" + port)
	http.ListenAndServe(ip + ":" + port, readRouter)
}

func qcWriteApi(ip string, port string) {
	WriteApiAPIService := qcwriteapi.NewWriteApiAPIService()
	WriteApiAPIController := qcwriteapi.NewWriteApiAPIController(WriteApiAPIService)
	writeRouter := qcwriteapi.NewRouter(WriteApiAPIController)

	fmt.Println("Write api server is listening on : ", ip + ":" + port)
	http.ListenAndServe(ip + ":" + port,  writeRouter)
}

func readConfigJsonDataFile(filename string) (c []Config) {
	fileContent, err := os.Open(filename)
	if err != nil {
		log.Println(err.Error())
	}
	defer fileContent.Close()

	byteResult, err  := ioutil.ReadAll(fileContent)
	if err != nil {
		fmt.Println("readall ", err)
	}

	byteResult = bytes.TrimPrefix(byteResult, []byte("\xef\xbb\xbf")) // Or []byte{239, 187, 191}

	var configs []Config
	err = json.Unmarshal([]byte(byteResult), &configs)
	if err != nil {
		fmt.Println("unmarshal ", err)
	}

	return configs
}

func printHelp() {
	fmt.Println("===========")
	fmt.Println("relay qcreadapi")
	fmt.Println("relay qcwriteapi")
	fmt.Println("===========")
}
