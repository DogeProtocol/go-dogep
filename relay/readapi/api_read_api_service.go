// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

/*
 * QC Read API
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * API version: v1
 */

package read

import (
	"context"
	"github.com/DogeProtocol/dp/log"
	"github.com/DogeProtocol/dp/relay"
	"github.com/DogeProtocol/dp/common"
	"github.com/DogeProtocol/dp/common/hexutil"
	"github.com/DogeProtocol/dp/core/types"
	"github.com/DogeProtocol/dp/rpc"
	"net/http"
	"errors"
)

// ReadApiAPIService is a service that implements the logic for the ReadApiAPIServicer
// This service should implement the business logic for every endpoint for the ReadApiAPI API.
// Include any external packages or services that will be required by this service.
type ReadApiAPIService struct {

}

type rpcTransaction struct {
	tx *types.Transaction
	TxExtraInfo
}

type TxExtraInfo struct {
	BlockNumber *string         `json:"blockNumber,omitempty"`
	BlockHash   *common.Hash    `json:"blockHash,omitempty"`
	From        *common.Address `json:"from,omitempty"`
}

// NewReadApiAPIService creates a default api service
func NewReadApiAPIService() *ReadApiAPIService {
	return &ReadApiAPIService{}
}

// GetAccountDetails - Get account details
func (s *ReadApiAPIService) GetAccountDetails(ctx context.Context, address string) (ImplResponse, error) {

	log.Info(relay.InfoTitleAccountDetails, "-", relay.MsgDial, relay.DIAL_READ_URL)

	client, err := rpc.Dial(relay.DIAL_READ_URL)
	if err != nil {
		log.Error(relay.MsgDial, http.StatusInternalServerError, errors.New(err.Error()))
		return Response(http.StatusInternalServerError, nil), errors.New(err.Error())
	}
	defer client.Close()

	if !common.IsHexAddress(address) {
		log.Error(relay.MsgAddress, http.StatusBadRequest, relay.ErrInvalidAddress)
		return Response(http.StatusBadRequest, nil), relay.ErrInvalidAddress
	}

	var balance *hexutil.Big
	err = client.CallContext(ctx, &balance, "eth_getBalance", common.HexToAddress(address), "latest")
	if err != nil {
		log.Error(relay.MsgBalance, http.StatusMethodNotAllowed, errors.New(err.Error()))
		return Response(http.StatusMethodNotAllowed, nil), errors.New(err.Error())
	}

	var nonce *hexutil.Big
	err = client.CallContext(ctx, &nonce, "eth_getTransactionCount", common.HexToAddress(address), "latest")
	if err != nil {
		log.Error(relay.MsgNonce, http.StatusMethodNotAllowed, errors.New(err.Error()))
		return Response(http.StatusMethodNotAllowed, nil), errors.New(err.Error())
	}

	var blockNumber *hexutil.Uint64
	err = client.CallContext(ctx, &blockNumber, "eth_blockNumber")
	if err != nil {
		log.Error(relay.MsgBlockNumber, http.StatusMethodNotAllowed, errors.New(err.Error()))
		return Response(http.StatusMethodNotAllowed, nil), errors.New(err.Error())
	}

	accountBalance, err := hexutil.DecodeBig(balance.String())
	if err != nil {
		log.Error(relay.MsgBalance, http.StatusUnprocessableEntity, errors.New(err.Error()))
		return Response(http.StatusUnprocessableEntity, nil), errors.New(err.Error())
	}

	accountNonce, err := hexutil.DecodeBig(nonce.String())
	if err != nil {
		log.Error(relay.MsgNonce, http.StatusUnprocessableEntity, errors.New(err.Error()))
		return Response(http.StatusUnprocessableEntity, nil), errors.New(err.Error())
	}

	latestBlockNumber, err := hexutil.DecodeBig(blockNumber.String())
	if err != nil {
		log.Error(relay.MsgBlockNumber, http.StatusUnprocessableEntity, errors.New(err.Error()))
		return Response(http.StatusUnprocessableEntity, nil), errors.New(err.Error())
	}

	b := accountBalance.String()
	n := accountNonce.Int64()
	l := latestBlockNumber.Int64()

	log.Info(relay.InfoTitleAccountDetails,  address, http.StatusOK)
	return Response(http.StatusOK, AccountDetailsResponse{
		AccountDetails{&b,&n,&l}}), nil
}

// GetTransaction - Get transaction
func (s *ReadApiAPIService) GetTransaction(ctx context.Context, hash string) (ImplResponse, error) {

	log.Info(relay.InfoTitleTransaction, relay.MsgDial, relay.DIAL_READ_URL)

	client, err := rpc.Dial(relay.DIAL_READ_URL)
	if err != nil {
		log.Error(relay.MsgDial, http.StatusInternalServerError, errors.New(err.Error()))
		return Response(http.StatusInternalServerError, nil), errors.New(err.Error())
	}
	defer client.Close()

	if !common.IsHexAddress(hash)  {
		log.Error(relay.MsgHash, http.StatusBadRequest, relay.ErrInvalidHash)
		return  Response(http.StatusBadRequest, nil), relay.ErrInvalidHash
	}

	var json *rpcTransaction
	err =  client.CallContext(ctx, &json, "eth_getTransactionByHash", common.HexToHash(hash))
	if err != nil {
		log.Error(relay.MsgTransaction, http.StatusMethodNotAllowed, errors.New(err.Error()))
		return  Response(http.StatusMethodNotAllowed, nil), errors.New(err.Error())
	}

	if json == nil {
		if _, r, _ := json.tx.RawSignatureValues(); r == nil {
			log.Error(relay.MsgTransaction, http.StatusMethodNotAllowed, relay.ErrTransWithoutSign)
			return  Response(http.StatusMethodNotAllowed, nil), relay.ErrTransWithoutSign
		}

		tx := json.tx

		var blochHash string
		var blockNumber  int64

		var signer types.Signer
		signer = types.LatestSignerForChainID(tx.ChainId())
		from, _ := types.Sender(signer, tx)

		gas :=  hexutil.Uint64(tx.Gas())
		gasPrice := (*hexutil.Big)(tx.GasPrice())
		input := hexutil.Bytes(tx.Data())
		transNonce := hexutil.Uint64(tx.Nonce())
		to := tx.To().Hex()
		value := (*hexutil.Big)(tx.Value())

		n, err := hexutil.DecodeBig(transNonce.String())
		if err != nil {
			log.Error(relay.MsgNonce, http.StatusUnprocessableEntity, errors.New(err.Error()))
			return  Response(http.StatusUnprocessableEntity, nil), errors.New(err.Error())
		}
		nonce := n.Int64()

		//var receipt map[string]interface{}
		var receipt *types.Receipt
		err =  client.CallContext(ctx, &receipt, "eth_getTransactionReceipt", common.HexToHash(hash))
		if err != nil {
			log.Error(relay.MsgTransactionReceipt, http.StatusMethodNotAllowed, errors.New(err.Error()))
			return  Response(http.StatusMethodNotAllowed, nil), errors.New(err.Error())
		}

		var transactionReceipt  TransactionReceipt
		if receipt != nil {
			//	blochHash =  receipt["cumulativeGasUsed"].(string)
			//	blockNumber = receipt["cumulativeGasUsed"].(string)
			//	cumulativeGasUsed := receipt["cumulativeGasUsed"].(string)
			//	effectiveGasPrice := receipt["effectiveGasPrice"].(string)
			//	gasUsed := receipt["gasUsed"].(string)
			//	status := receipt["status"].(string)
			//	txHash := receipt["transactionHash"].(string)
			//	t := receipt["type"].(string)

			blochHash =  receipt.BlockHash.String()
			blockNumber =  receipt.BlockNumber.Int64()
			cumulativeGasUsed := hexutil.Uint64(receipt.CumulativeGasUsed)
			effectiveGasPrice :=  hexutil.Uint64(tx.GasPrice().Uint64())
			gasUsed := hexutil.Uint64(receipt.GasUsed)
			status := hexutil.Uint(receipt.Status)
			t :=  hexutil.Uint(tx.Type())
			txHash := receipt.TxHash

			transactionReceipt =  TransactionReceipt{
				cumulativeGasUsed.String(), effectiveGasPrice.String(), gasUsed.String(),
				status.String(), txHash.String(), t.String()}
		} else {
			log.Info(relay.InfoTitleTransaction, hash, http.StatusPartialContent)
			return  Response(http.StatusPartialContent, TransactionResponse{TransactionDetails{
				&blochHash, &blockNumber, from.String(),gas.String(), gasPrice.String(), hash,
				input.String(), nonce , &to,value.String(),
				transactionReceipt}}),	nil
		}

		log.Info(relay.InfoTitleTransaction, hash, http.StatusOK)
		return Response(http.StatusOK,TransactionResponse{TransactionDetails{
			&blochHash, &blockNumber, from.String(),gas.String(), gasPrice.String(), hash,
			input.String(), nonce , &to,value.String(),
			transactionReceipt}}),	nil
	}

	log.Info(relay.InfoTitleTransaction, hash, http.StatusNoContent)
	return  Response(http.StatusNoContent,nil), nil
}
