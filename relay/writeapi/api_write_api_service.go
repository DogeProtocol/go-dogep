// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

/*
 * QC Write API
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * API version: v1
 */

package write

import (
	"context"
	"encoding/hex"
	"github.com/DogeProtocol/dp/log"
	"github.com/DogeProtocol/dp/relay"
	"github.com/DogeProtocol/dp/common"
	"github.com/DogeProtocol/dp/core/types"
	"github.com/DogeProtocol/dp/rlp"
	"github.com/DogeProtocol/dp/rpc"
	"net/http"
	"errors"
	"strings"
)



// WriteApiAPIService is a service that implements the logic for the WriteApiAPIServicer
// This service should implement the business logic for every endpoint for the WriteApiAPI API.
// Include any external packages or services that will be required by this service.
type WriteApiAPIService struct {

}

// NewWriteApiAPIService creates a default api service
func NewWriteApiAPIService() *WriteApiAPIService {
	return &WriteApiAPIService{}
}

// SendTransaction - Send Transaction
func (s *WriteApiAPIService) SendTransaction(ctx context.Context, sendTransactionRequest SendTransactionRequest) (ImplResponse, error) {

	log.Info(relay.InfoTitleSendTransaction, relay.MsgDial, relay.DIAL_WRITE_URL)

	client, err := rpc.Dial(relay.DIAL_WRITE_URL)
	if err != nil {
		log.Error(relay.MsgDial, http.StatusInternalServerError, errors.New(err.Error()))
		return Response(http.StatusInternalServerError, nil), errors.New(err.Error())
	}
	defer client.Close()

	rawTxHex := sendTransactionRequest.TxnData

	if(len(strings.TrimSpace(rawTxHex)) == 0) {
		log.Error(relay.MsgRawRawTxHex, http.StatusBadRequest, relay.ErrEmptyRawTxHex)
		return  Response(http.StatusBadRequest, nil), relay.ErrEmptyRawTxHex
	}

	rawTxData, err := hex.DecodeString(rawTxHex[2:])
	if err != nil {
		log.Error(relay.MsgRawRawTxHex, http.StatusUnprocessableEntity, errors.New(err.Error()))
		return  Response(http.StatusUnprocessableEntity, nil), errors.New(err.Error())
	}

	var tx *types.Transaction
	err = rlp.DecodeBytes(rawTxData, &tx)
	if err != nil {
		log.Error(relay.MsgTransaction, http.StatusUnprocessableEntity, errors.New(err.Error()))
		return  Response(http.StatusUnprocessableEntity, nil), errors.New(err.Error())
	}

/*
	fmt.Println(tx.Hash().Hex())        // 0x5d49fcaa394c97ec8a9c3e7bd9e8388d420fb050a52083ca52ff24b3b65bc9c2
	fmt.Println(tx.Value().String())    // 10000000000000000
	fmt.Println(tx.Gas())               // 105000
	fmt.Println(tx.GasPrice().Uint64()) // 102000000000
	fmt.Println(tx.Nonce())             // 110644
	fmt.Println(tx.Data())              // []
	fmt.Println(tx.To().Hex())          // 0x55fE59D8Ad77035154dDd0AD0388D09Dd4047A8e

	if msg, err := tx.AsMessage(types.NewLondonSignerDefaultChain(); err == nil {
		fromAddress = msg.From().Hex()
	}
*/


	var txHash *common.Hash
	err = client.CallContext(ctx, &txHash, "eth_sendRawTransaction", rawTxHex)
	if err != nil {
		log.Error(relay.MsgSend, relay.MsgTransaction, http.StatusMethodNotAllowed, errors.New(err.Error()))
		return  Response(http.StatusMethodNotAllowed, nil), errors.New(err.Error())
	}

	log.Info(relay.MsgSend, relay.MsgTransaction, relay.MsgHash, txHash, http.StatusOK)
	return Response(http.StatusOK, txHash), nil
}
